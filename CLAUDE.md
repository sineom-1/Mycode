# Claude 编程协作规范

> 核心理念：如无必要，勿增实体。简单优于复杂，清晰优于晦涩。

## 1) 语言与沟通

- 与用户沟通：一律简体中文。
- 与外部模型/工具交互：`PROMPT` 以英文为主；但涉及前端/移动端/小程序等需求时，必须在 `PROMPT` 中包含用户原始需求（尽量原文粘贴，不要转述/改写）。

## 2) 核心原则

- 奥卡姆 / KISS / YAGNI：最简单可行方案；标准库优先；不做未提需求的扩展。
- SRP / OCP / DRY：职责单一；消除重复；扩展不破坏既有行为。
- 最小改动：只改与需求相关的范围；不顺手“顺便优化”。
- 多模型协作：按需使用 Codex/Gemini 做原型、Debug 与 Review；任何外部产出仅作参考，需质疑其结论并独立判断。
- 原型前置：需要原型时必须索要统一 diff（read-only）；原型不可直接套用，必须按项目规范重写为生产级代码。
- 立即审查：完成编码后进行质量审查，覆盖需求完成度、逻辑/性能/安全风险。
- 检索-提问-定位循环：先尽量检索相关文件，再多角度提问澄清需求，精准定位改动点，信息不足则继续迭代。
- 代码最小化：只做需求内改动，风格精简高效，必要时用简短伪代码说明计划。
- 语言分工：与用户中文；与外部模型/工具英文（命令、标识符、日志保持原文）。
- 前端铁律：前端/移动端需求优先用 Gemini；不得让 Gemini 编写复杂后端逻辑；以 Gemini 原型为基点重写。

## 3) Workflow

**强制执行**：以下流程适用于所有任务，始终强制执行，不得降级或跳步。

### Phase 1: 上下文全量检索 (Auggie Interface)
**执行条件**：在生成任何建议或代码前。
1.  **工具调用**：调用 `mcp__auggie-mcp__codebase-retrieval`。
2.  **检索策略**：
    - 禁止基于假设（Assumption）回答。
    - 使用自然语言（NL）构建语义查询（Where/What/How）。
    - **完整性检查**：必须获取相关类、函数、变量的完整定义与签名。若上下文不足，触发递归检索。
3.  **需求对齐**：若检索后需求仍有模糊空间，**必须**向用户输出引导性问题列表，直至需求边界清晰（无遗漏、无冗余）。


### Phase 2: 多模型协作分析 
1.  **分发输入**：：将用户的**原始需求**（不带预设观点）分发给 Codex 和 Gemini。注意，Codex/Gemini都有完善的CLI系统，所以**仅需给出入口文件和row index**(而非Snippet)。
2.  **方案迭代**：
    - 要求模型提供多角度解决方案。
    - 触发**交叉验证**：整合各方思路，进行迭代优化，在过程中执行逻辑推演和优劣势互补，直至生成无逻辑漏洞的 Step-by-step 实施计划。
3.  **强制阻断 (Hard Stop)**：向用户展示最终实施计划（含适度伪代码）；必须以加粗文本输出询问："Shall I proceed with this plan? (Y/N)"；立即终止当前回复。绝对禁止在收到用户明确的 "Y" 之前执行 Phase 3 或调用任何文件读取工具。

### Phase 3: 原型获取
- **Route A: 前端/UI/样式 (Gemini Kernel)**
  - **限制**：上下文 < 32k。gemini对于后端逻辑的理解有缺陷，其回复需要客观审视。
  - **指令**：请求 CSS/React/Vue 原型。以此为最终前端设计原型与视觉基准。
- **Route B: 后端/逻辑/算法 (Codex Kernel)**
  - **能力**：利用其逻辑运算与 Debug 能力。
  - **指令**：请求逻辑实现原型。
- **通用约束**：：在与Codex/Gemini沟通的任何情况下，**必须**在 Prompt 中**明确要求** 返回 `Unified Diff Patch`，严禁Codex/Gemini做任何真实修改。

### Phase 4: 编码实施
**执行准则**：
1.  **逻辑重构**：基于 Phase 3 的原型，去除冗余，**重写**为高可读、高可维护性、企业发布级代码。
2.  **文档规范**：非必要不生成注释与文档，代码自解释。
3.  **最小作用域**：变更仅限需求范围，**强制审查**变更是否引入副作用并做针对性修正。

### Phase 5: 审计与交付
1.  **自动审计**：变更生效后，**强制立即调用** Codex与Gemini **同时进行** Code Review，并进行整合修复。
2.  **交付**：审计通过后反馈给用户。

----

## 4) Commands / Agents（推荐入口）

- `/explore`：入口定位与调用链（agent: `explorer`）
- `/plan`：方案设计与任务拆解（agent: `architect`）
- `/code`：实现与必要质量补齐（agent: `coder`）
- `/check`：审查/测试/诊断（agent: `guardian`）
- `/doc`：文档与变更说明（agent: `doc-writer`）
- `/dev`：完整 feature-dev 流程（强约束，适合中大型需求）

## 5) Codex / Gemini（CLI Bridge skills）

- `collaborating-with-codex`：后端原型、Debug、Review；必须保存/复用 `SESSION_ID`；原型阶段必须 read-only 且只输出 unified diff。
- `collaborating-with-gemini`：需求澄清、任务规划、前端/移动端原型；前端需求尽量原文粘贴；严禁让 Gemini 编写复杂后端逻辑。
- 细则与参数：见 `skills/collaborating-with-codex/SKILL.md`、`skills/collaborating-with-gemini/SKILL.md`；通用调用模板见 `skills/templates/SKILL.md`。
- 共同要求：Codex/Gemini 仅为参考，必须批判性审视并独立判断；原型不可直接套用；外部模型不得直接写文件（以 unified diff 作为只读输入）。

## 6) 工具调用与降级

- 调用优先级：代码检索（Auggie）→ 官方文档（Context7）→ 复杂规划（Sequential Thinking）→ 外部搜索（DuckDuckGo 官方域）→ Playwright/DeepWiki（确需时）。
- 外部调用：每轮最多 1 个 MCP 服务；限定 `relative_path/topic`；失败重试一次后降级本地处理并标注缺口。
- 会话管理：Codex/Gemini 必须记录并复用 `SESSION_ID`，避免上下文丢失。

## 7) Git 提交信息（如需）

- 历史风格：先执行 `git log -n 5` 观察仓库既有风格。
- 版本检测：优先从 `package.json` / `pom.xml` / 最新 git tag 等确定当前版本；无法检测则**省略版本前缀**（禁止猜测）。
- 提交信息格式：`[版本号]：[摘要]。[详情，以分号分隔];`
  - 语言：中文（简体）；正文**单段落**（不换行）
  - 禁止：`Co-Authored-By`、`Generated by`、AI 免责声明

## 8) 禁止事项

- 跳过关键澄清、直接拍脑袋实现。
- 跳过原型或审查；直接照搬原型不重写。
- 未经请求扩大改动范围或预留未来扩展。
- 不记录/不复用 `SESSION_ID`。
- 新增/修改文件使用非 UTF-8（无 BOM）或引入乱码。

## 9) 附录：工具调用规范

- 通用
  - 每轮最多 1 个 MCP 服务；限定 `relative_path/topic`，避免过度抓取。
  - 原型阶段必须 `sandbox="read-only"`，并要求**只输出 unified diff patch**（不得直接写文件）。
  - Codex/Gemini 必须保存并复用 `SESSION_ID`，避免上下文丢失。
- Codex / Gemini
  - 细则与参数：见 `skills/collaborating-with-codex/SKILL.md`、`skills/collaborating-with-gemini/SKILL.md`。
- Auggie（代码检索）
  - 流程：`mcp__auggie-context__codebase-retrieval`；使用自然语言（Where/What/How）构建语义查询；必须获取相关类/函数/变量的完整定义与签名；上下文不足则递归检索。
  - 约束：在生成任何建议或代码前必须执行；若检索后仍有模糊点，必须输出引导性问题列表直至需求边界清晰。
  - 适用场景：定位文件、理解代码流程、批量编辑、深度语义搜索。
- Context7（官方文档）
  - 流程：`resolve-library-id` → `get-library-docs`；tokens≤5000，指定 topic，必要时翻页；mode=code/info 视需求而定。
  - 单轮仅调用一个外部文档服务；无法获取时降级 DuckDuckGo（同一轮不要并行外部搜索）。
- Sequential Thinking（复杂规划）
  - 适用：非简单任务的多步骤规划/诊断；输出 6–10 步可执行计划，不暴露推理过程。
  - 参数：`total_thoughts≤10`；完成后更新 plan 或直接执行。
- Shrimp Task Manager（任务拆分/跟踪）
  - 用途：`split_tasks` / `plan_task` / `execute_task` / `update_task` / `verify_task`。
  - `updateMode` 默认 `clearAllTasks`（除非明确需要保留旧任务）；JSON 禁止注释；任务保持原子性并写清 `dependencies`。
  - 仅需清空旧任务集时用 `clearAllTasks`；需要保留任务时优先 `append` / `selective`。
- 降级
  - 工具失败：重试一次 → 本地处理并在汇报中标注缺口/风险。

```markdown
# Global Protocols

- 语言：与用户简体中文；与工具/外部模型英文（命令、标识符、日志保持原文）。
- Workflow：严格按“检索 → 澄清 → 计划 →（可选原型）→ 实现 → 审查 → 汇报”推进；进入“实现”（修改文件）前必须获得用户明确批准。
- 多模型协作（可选，但推荐用于中大型需求）：
  - 后端/逻辑/Review：优先 Codex；前端/UI/样式：优先 Gemini
  - 调用形态：`python /path/to/scripts/*_bridge.py --cd "/path/to/project" --PROMPT "..." [OPTIONS]`
  - 原型/补丁约束：必须要求 “OUTPUT: Unified Diff Patch ONLY. Do not modify files.”
  - 会话：捕获并复用 `SESSION_ID`（续对话追加 `--SESSION_ID <ID>`）
- 代码主权：外部模型产出视为“脏原型”，仅作参考；必须审视后按项目规范重写。
```
